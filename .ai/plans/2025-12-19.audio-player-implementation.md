# Audio Player Implementation Plan

**Created:** 2025-12-19
**Status:** Reviewed - Ready for Implementation

## Executive Summary

Implement the DarkMatter DSL audio player feature in the Library module, enabling users to embed audio content (MP3/WAV) in markdown documents via the `::audio` directive. The feature includes metadata extraction, caching, dual rendering modes (file reference vs base64 inline), and HTML5 audio player generation.

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Parse `::audio <source> [name]` directive for local and remote audio files | High | Rust Developer |
| FR-2 | Extract audio metadata (duration, bitrate, sample rate, channels, ID3 tags) | High | Rust Developer |
| FR-3 | Cache metadata by content hash in SurrealDB | High | Rust Developer |
| FR-4 | Generate HTML5 `<audio>` player with controls | High | Rust Developer |
| FR-5 | Support dual rendering modes (file reference vs base64 inline) | High | Rust Developer |
| FR-6 | Copy audio files to output directory with hash-based filenames | Medium | Rust Developer |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Metadata extraction caching | No reprocessing on unchanged files | Rust Developer |
| NFR-2 | Browser compatibility | HTML5 audio support in Chrome, Firefox, Safari, Edge | Rust Developer |
| NFR-3 | Performance | Parallel processing support via rayon | Rust Developer |
| NFR-4 | Error handling | Structured errors with thiserror, traced with tracing | Rust Developer |
| NFR-5 | File size (inline mode) | Accept ~33% size increase for portability | Rust Developer |

## Architecture Overview

The audio player system is integrated into the Library module's markdown parsing pipeline:

1. **Parsing Phase**: Detect `::audio` directives in pulldown-cmark event stream
2. **Processing Phase**: Extract metadata, check cache, copy files
3. **Caching Phase**: Store metadata in SurrealDB by content hash
4. **HTML Generation Phase**: Produce HTML5 `<audio>` element with styling

### Component Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                    Markdown Parser                          │
│                  (pulldown-cmark)                            │
└───────────────────────┬─────────────────────────────────────┘
                        │ Event::Text("::audio ...")
                        ▼
┌─────────────────────────────────────────────────────────────┐
│              AudioProcessor::process_audio()                │
├─────────────────────────────────────────────────────────────┤
│  1. Load audio bytes (local file or remote URL)             │
│  2. Detect format (MP3/WAV)                                 │
│  3. Compute content hash (xxh3_64)                          │
│  4. Check AudioCache (SurrealDB)                            │
│  5. Extract metadata (symphonia) if cache miss              │
│  6. Copy to output_dir/audio/{hash}.{ext}                   │
│  7. Generate base64 data if inline_mode                     │
└───────────────────────┬─────────────────────────────────────┘
                        │ AudioOutput
                        ▼
┌─────────────────────────────────────────────────────────────┐
│          HtmlGenerator::generate_audio_html()               │
├─────────────────────────────────────────────────────────────┤
│  - Produce <div class="audio-player">                       │
│  - Embed <audio controls> with src (path or data URI)       │
│  - Display audio name and duration                          │
└───────────────────────┬─────────────────────────────────────┘
                        │ HTML String
                        ▼
┌─────────────────────────────────────────────────────────────┐
│                 Markdown Event Stream                       │
│                Event::Html(audio_html)                      │
└─────────────────────────────────────────────────────────────┘
```

### Data Flow

1. User writes: `::audio ./podcast.mp3 "Episode 42"`
2. Parser emits `Event::Text("::audio ./podcast.mp3 \"Episode 42\"")`
3. Custom event handler detects audio directive
4. AudioProcessor:
   - Reads file bytes
   - Computes hash: `a1b2c3d4e5f67890`
   - Checks cache for `(resource_hash, content_hash)` pair
   - On cache miss: extracts metadata via symphonia
   - Copies to `output_dir/audio/a1b2c3d4e5f67890.mp3`
   - Returns `AudioOutput` with metadata
5. HtmlGenerator produces:
   ```html
   <div class="audio-player">
     <audio controls preload="metadata">
       <source src="audio/a1b2c3d4e5f67890.mp3" type="audio/mpeg">
     </audio>
     <div class="audio-info">
       <span class="audio-name">Episode 42</span>
       <span class="audio-duration">12:34</span>
     </div>
   </div>
   ```
6. Parser emits `Event::Html(audio_html)`

## Phases

### Phase 1: Core Type Definitions and Error Handling

**Principal Owner:** Rust Developer

**Goal:** Establish foundational types for audio processing (input/output, formats, metadata, errors).

**Dependencies:** None

**Blast Radius:** `""` (all tests - foundational types affect multiple modules)

**Deliverables:**
- `lib/src/audio/types.rs`: `AudioSource`, `AudioInput`, `AudioOutput`, `AudioFormat`, `AudioMetadata`
- `lib/src/error/mod.rs`: Add `AudioError` enum (centralized error handling)
- `tests/fixtures/audio/`: Minimal test fixtures (<50KB, 5s duration, known metadata)
- Unit tests for type construction and error formatting

**Technical Details:**

Files to create:
- `lib/src/audio/mod.rs` - Module entry point
- `lib/src/audio/types.rs` - Core types
- `tests/fixtures/audio/test.mp3` - Minimal MP3 test fixture
- `tests/fixtures/audio/test.wav` - Minimal WAV test fixture

Files to modify:
- `lib/src/error/mod.rs` - Add `AudioError` enum following image module pattern

Key types:
- `AudioSource` enum (Local/Remote) with `resource_hash()` method using xxhash-rust xxh3_64
- `AudioFormat` enum (Mp3/Wav) with `#[non_exhaustive]`, `from_extension()`, `mime_type()`, `extension()`
- `AudioMetadata` struct with duration, bitrate, sample_rate, channels, ID3 tags (title, artist, album)
- `AudioError` enum in `lib/src/error/mod.rs` covering ReadFailed, UnsupportedFormat, FetchFailed, MetadataFailed, CacheFailed

Integration points:
- Uses centralized error handling in `lib/src/error/mod.rs` (matching image module pattern)
- Add `AudioError` to `CompositionError` enum
- Update `lib/src/lib.rs` re-exports for error types

**Acceptance Criteria:**
- [ ] All types compile without warnings
- [ ] `AudioSource::resource_hash()` produces consistent u64 hashes using xxh3_64
- [ ] `AudioFormat` uses `#[non_exhaustive]` for future compatibility
- [ ] `AudioFormat::from_extension()` correctly identifies mp3/wav
- [ ] `AudioError` variants have clear Display messages
- [ ] `AudioError` added to centralized `lib/src/error/mod.rs` (not separate file)
- [ ] Test fixtures created: test.mp3 and test.wav (<50KB each, ~5s duration)
- [ ] Unit tests cover all enum variants and edge cases
- [ ] Unit tests verify error Display formatting

---

### Phase 2: SurrealDB Cache Schema and Operations

**Principal Owner:** Rust Developer

**Goal:** Implement audio metadata caching in SurrealDB to avoid reprocessing unchanged files.

**Dependencies:** Phase 1 (requires `AudioError`, `AudioMetadata`)

**Blast Radius:** `tests/unit/audio/**/*.rs, tests/unit/cache/**/*.rs`

**Deliverables:**
- `lib/src/audio/cache.rs`: `AudioCache` struct with `new()`, `get()`, `upsert()`, `clear()`
- `lib/src/cache/schema.rs`: Add audio_cache table schema (update existing file)
- Unit tests for cache operations (hit, miss, upsert, clear)
- Integration test for cache persistence across DB reinit

**Technical Details:**

Files to create:
- `lib/src/audio/cache.rs`

Files to modify:
- `lib/src/cache/schema.rs` - Add audio_cache table definition

Key components:
- `AudioCache` struct wrapping `Surreal<Db>`
- `AudioCacheEntry` struct matching SurrealDB schema
- `NewAudioCacheEntry` for insertions

SurrealDB schema (add to `lib/src/cache/schema.rs`):
```sql
-- Audio metadata cache
DEFINE TABLE audio_cache SCHEMAFULL;
DEFINE FIELD resource_hash ON audio_cache TYPE string;
DEFINE FIELD content_hash ON audio_cache TYPE string;
DEFINE FIELD created_at ON audio_cache TYPE datetime DEFAULT time::now();
DEFINE FIELD source_type ON audio_cache TYPE string;
DEFINE FIELD source ON audio_cache TYPE string;
DEFINE FIELD format ON audio_cache TYPE string;
DEFINE FIELD duration_secs ON audio_cache TYPE option<float>;
DEFINE FIELD bitrate ON audio_cache TYPE option<int>;
DEFINE FIELD sample_rate ON audio_cache TYPE option<int>;
DEFINE FIELD channels ON audio_cache TYPE option<int>;
DEFINE INDEX idx_audio_resource ON audio_cache FIELDS resource_hash UNIQUE;
DEFINE INDEX idx_audio_lookup ON audio_cache FIELDS resource_hash, content_hash;
```

Integration points:
- Uses existing SurrealDB connection from composition lib
- Database path: `{repo_root}/.composition.db` or `$HOME/.composition.db`
- Schema added to existing `schema.rs` (not separate migration)

**Acceptance Criteria:**
- [ ] `AudioCache::new()` initializes RocksDB backend at correct path
- [ ] `AudioCache::get()` returns None on cache miss
- [ ] `AudioCache::get()` returns Some(entry) on cache hit
- [ ] `AudioCache::upsert()` creates new entry on insert
- [ ] `AudioCache::upsert()` updates existing entry on conflict
- [ ] `AudioCache::clear()` deletes all audio_cache entries
- [ ] Unit tests verify cache hit/miss logic
- [ ] Unit tests verify upsert idempotency
- [ ] Unit tests verify cache clear operation
- [ ] Integration test verifies cache persists across DB drop/reinit

---

### Phase 3: Audio Metadata Extraction (Symphonia Integration)

**Principal Owner:** Rust Developer

**Goal:** Extract audio metadata (duration, bitrate, sample rate, ID3 tags) using Symphonia.

**Dependencies:** Phase 1 (requires types)

**Blast Radius:** `tests/unit/audio/**/*.rs`

**Deliverables:**
- `lib/src/audio/metadata.rs`: `extract_audio_metadata()` function
- Helper functions: `load_audio_bytes()`, `detect_audio_format()`, `compute_content_hash()`
- `lib/Cargo.toml`: Add `symphonia = { version = "0.5", features = ["mp3", "wav"] }` dependency
- Unit tests with sample MP3/WAV files
- Property tests for hash determinism

**Technical Details:**

Files to create:
- `lib/src/audio/metadata.rs`

Files to modify:
- `lib/Cargo.toml` - Add symphonia dependency with mp3/wav features

Key functions:
- `load_audio_bytes(source: &AudioSource) -> Result<(Vec<u8>, String)>`
  - Loads from local file (sync operation)
  - Validates path doesn't escape via symlinks (canonicalize + check)
  - Remote URLs return clear error: "Remote URL fetching not yet implemented"
- `detect_audio_format(source: &AudioSource, bytes: &[u8]) -> Result<AudioFormat>`
  - Extension-based detection first
  - Magic byte fallback (MP3: ID3 or MPEG sync, WAV: RIFF header)
  - Validate extension matches magic bytes (error on mismatch for security)
- `compute_content_hash(bytes: &[u8]) -> String`
  - xxh3_64 hash formatted as hex
  - Deterministic (property tested)
- `extract_audio_metadata(bytes: &[u8], format: AudioFormat) -> Result<AudioMetadata>`
  - Symphonia probe and format reading
  - Extract duration (from sample_rate + n_frames), bitrate, sample_rate, channels
  - Extract ID3 tags (TITLE/TIT2, ARTIST/TPE1, ALBUM/TALB)
  - Graceful degradation: use defaults if metadata extraction fails

Integration points:
- Add `symphonia = { version = "0.5", features = ["mp3", "wav"] }` to dependencies
- Uses xxhash-rust for content hashing (already in project)

**Acceptance Criteria:**
- [ ] `symphonia` dependency added to `lib/Cargo.toml` with mp3/wav features
- [ ] `load_audio_bytes()` reads local MP3/WAV files correctly
- [ ] `load_audio_bytes()` rejects symlinks outside project scope
- [ ] `load_audio_bytes()` returns clear error for remote URLs
- [ ] `detect_audio_format()` identifies MP3 by ID3 tag or sync bytes
- [ ] `detect_audio_format()` identifies WAV by RIFF header
- [ ] `detect_audio_format()` errors on extension/magic byte mismatch
- [ ] `compute_content_hash()` produces consistent hashes (property test: same bytes → same hash)
- [ ] `extract_audio_metadata()` extracts duration from sample rate and frame count
- [ ] `extract_audio_metadata()` extracts ID3 tags when present
- [ ] `extract_audio_metadata()` uses defaults if extraction fails (graceful degradation)
- [ ] Unit tests cover both MP3 and WAV files (using fixtures from Phase 1)
- [ ] Unit tests verify error handling for unsupported formats
- [ ] Unit tests verify corrupted/truncated file handling
- [ ] Property test: `compute_content_hash()` is deterministic

---

### Phase 4: Audio Processing Pipeline

**Principal Owner:** Rust Developer

**Goal:** Orchestrate the complete audio processing flow: load, hash, cache check, metadata extraction, file copying.

**Dependencies:** Phase 2 (cache), Phase 3 (metadata extraction)

**Blast Radius:** `tests/unit/audio/**/*.rs, tests/integration/**/*.rs`

**Deliverables:**
- `lib/src/audio/processor.rs`: `process_audio()` function (public async API)
- `lib/src/audio/processor.rs`: `process_audio_sync()` function (internal sync logic)
- `lib/src/audio/types.rs`: Add `AudioProcessingConfig` for resource limits
- Integration of cache, metadata extraction, file I/O
- Integration tests with end-to-end processing

**Technical Details:**

Files to create:
- `lib/src/audio/processor.rs`

Files to modify:
- `lib/src/audio/types.rs` - Add `AudioProcessingConfig` struct

Key functions:
```rust
// Public async API wrapper
pub async fn process_audio(
    input: AudioInput,
    output_dir: &Path,
    cache: &AudioCache,
    inline_mode: bool,
    config: &AudioProcessingConfig,
) -> Result<AudioOutput>

// Internal sync processing (called via tokio::task::spawn_blocking)
pub(crate) fn process_audio_sync(
    input: AudioInput,
    output_dir: &Path,
    cache: &AudioCache,
    inline_mode: bool,
    config: &AudioProcessingConfig,
) -> Result<AudioOutput>
```

Processing steps:
1. Compute resource hash from source
2. Load audio bytes (sync)
3. Detect format
4. Compute content hash
5. Check cache with `(resource_hash, content_hash)` (async)
6. If cache miss: extract metadata (sync), upsert cache (async)
7. Validate file size against `config.max_inline_size` if `inline_mode`
8. Copy audio file to `output_dir/audio/{resource_hash}.{ext}`
9. Generate base64 data if `inline_mode` (using `base64 = "0.22"` crate)
10. Determine display name (priority: input.name > metadata.title > filename)
11. Return `AudioOutput`

New types:
```rust
pub struct AudioProcessingConfig {
    pub max_file_size: Option<u64>,      // bytes, None = unlimited
    pub max_inline_size: u64,            // bytes, 10MB default
    pub allowed_formats: Vec<AudioFormat>,
}
```

Integration points:
- Uses `AudioCache` from Phase 2
- Uses metadata extraction from Phase 3
- Uses `base64 = "0.22"` crate (already in dependencies)
- Creates `{output_dir}/audio/` directory if not exists
- Async/sync boundary: async wrapper calls sync logic via `spawn_blocking`

**Acceptance Criteria:**
- [ ] `process_audio()` async API wraps `process_audio_sync()` via spawn_blocking
- [ ] `AudioProcessingConfig` with max_file_size, max_inline_size, allowed_formats
- [ ] `process_audio_sync()` returns correct `AudioOutput` for valid input
- [ ] Cache hit skips metadata extraction (verify via tracing logs)
- [ ] Cache miss extracts metadata and updates cache
- [ ] Audio file copied to correct output path
- [ ] Base64 data generated when `inline_mode = true` using base64 crate
- [ ] File size validated: >max_inline_size logs warning, proceeds (doesn't fail)
- [ ] Display name follows priority: input.name > ID3 title > filename
- [ ] Integration tests verify full pipeline with sample files
- [ ] Integration tests verify file size limit warning (>10MB in inline mode)
- [ ] Error handling tested for missing files, unsupported formats

---

### Phase 5: HTML Generation

**Principal Owner:** Rust Developer

**Goal:** Generate HTML5 `<audio>` player markup from `AudioOutput`.

**Dependencies:** Phase 4 (requires `AudioOutput`)

**Blast Radius:** `tests/unit/audio/**/*.rs`

**Deliverables:**
- `lib/src/audio/html.rs`: `generate_audio_html()` function
- `AudioHtmlOptions` struct for configuration
- Helper function: `html_escape()`
- Unit tests for HTML output
- Snapshot tests for HTML structure verification

**Technical Details:**

Files to create:
- `lib/src/audio/html.rs`

Files to modify:
- `lib/Cargo.toml` - Add `insta = "1"` to dev-dependencies for snapshot testing

Key components:
- `AudioHtmlOptions` struct with `inline: bool`, `class: Option<String>`
- `generate_audio_html(output: &AudioOutput, options: &AudioHtmlOptions) -> String`
- `html_escape(s: &str) -> String` - escape &, <, >, "

HTML structure:
```html
<div class="audio-player">
  <audio controls preload="metadata">
    <source src="{path or data URI}" type="{mime_type}">
    Your browser does not support the audio element.
  </audio>
  <div class="audio-info">
    <span class="audio-name">{display_name}</span>
    <span class="audio-duration">{mm}:{ss}</span>
  </div>
</div>
```

Integration points:
- Uses `AudioOutput::path` or `AudioOutput::base64_data` depending on mode
- Formats duration as `{minutes}:{seconds:02}`
- Handles `None` duration gracefully (omit duration span)

**Acceptance Criteria:**
- [ ] `insta` crate added to dev-dependencies for snapshot testing
- [ ] `generate_audio_html()` produces valid HTML5 markup
- [ ] File reference mode uses `src="audio/{hash}.{ext}"`
- [ ] Inline mode uses `src="data:{mime};base64,{data}"`
- [ ] Display name and duration correctly rendered
- [ ] HTML special characters escaped in src and display name
- [ ] XSS prevention: test malicious input (e.g., `<script>`, `"onclick="`)
- [ ] Unit tests verify output for both modes (file reference, inline)
- [ ] Unit tests verify duration formatting: 0s→'0:00', 59s→'0:59', 60s→'1:00', 3661s→'61:01'
- [ ] Unit tests verify `None` duration handled gracefully
- [ ] Snapshot tests verify complete HTML structure (using insta)

---

### Phase 6: Markdown Parser Integration

**Principal Owner:** Rust Developer

**Goal:** Integrate audio processing into pulldown-cmark event stream processing.

**Dependencies:** Phase 4 (processor), Phase 5 (HTML generation)

**Blast Radius:** `tests/unit/render/**/*.rs, tests/integration/**/*.rs`

**Deliverables:**
- Event handler in `lib/src/render/mod.rs` (or similar) to detect `::audio` directive
- Parsing logic to extract source and optional name from directive
- Integration with existing markdown rendering pipeline
- Integration tests with complete markdown documents

**Technical Details:**

Files to modify:
- `lib/src/render/mod.rs` (or wherever pulldown-cmark event processing occurs)

Key logic:
```rust
match event {
    Event::Text(text) if text.starts_with("::audio ") => {
        let parts: Vec<&str> = text.trim_start_matches("::audio ")
            .splitn(2, ' ')
            .collect();
        let source_path = parts[0];
        let name = parts.get(1)
            .map(|s| s.trim_matches('"').to_string());

        let input = AudioInput {
            source: AudioSource::Local(PathBuf::from(source_path)),
            name,
        };

        let output = process_audio(input, output_dir, cache, inline_mode)?;
        let html = generate_audio_html(&output, &AudioHtmlOptions::default());

        Event::Html(html.into())
    }
    _ => event,
}
```

Integration points:
- Plugs into existing `render()` function's event stream processing
- Shares `output_dir` and `inline_mode` context from render state
- Uses existing `AudioCache` instance (initialized in `init()` or passed to `render()`)

**Acceptance Criteria:**
- [ ] Markdown with `::audio ./file.mp3` renders HTML audio player
- [ ] Markdown with `::audio ./file.mp3 "Custom Name"` uses custom name
- [ ] Directive parsing handles quoted names with spaces
- [ ] Directive parsing handles escaped quotes: `"Name with \"quotes\""`
- [ ] Directive parsing handles paths with spaces (without quotes)
- [ ] Missing source directive (just `::audio`) emits error
- [ ] Corrupted audio file emits error HTML (not panic): `<div class="audio-error">Failed to load audio: {error}</div>`
- [ ] Missing file with `!` suffix fails rendering
- [ ] Missing file with `?` suffix shows warning (doesn't fail)
- [ ] Errors in audio processing don't crash rendering (log error, emit fallback HTML)
- [ ] Integration tests verify end-to-end: markdown → HTML with audio player
- [ ] Integration tests verify inline mode produces base64 data URIs
- [ ] Integration tests verify multiple audio directives in same document

---

### Phase 7: CSS Styling and Documentation

**Principal Owner:** Rust Developer

**Goal:** Provide default CSS styling for audio player and document the feature.

**Dependencies:** Phase 6 (requires HTML structure)

**Blast Radius:** `tests/unit/html/**/*.rs, tests/integration/**/*.rs`

**Deliverables:**
- Default CSS for `.audio-player` class
- Documentation in `docs/features/darkmatter-dsl.md` (update existing)
- Example markdown files in `examples/audio/`
- Updated README with audio feature mention

**Technical Details:**

Files to create/modify:
- `lib/assets/audio-player.css` (or embedded in HTML generation)
- `examples/audio/podcast-example.md`
- `examples/audio/music-example.md`
- `docs/features/darkmatter-dsl.md` (already exists, update section)

CSS structure (from design doc):
```css
.audio-player {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  padding: 1rem;
  border: 2px solid #e5e7eb;
  border-radius: 0.5rem;
  background-color: #1f2937;
  color: #f9fafb;
  max-width: 800px;
}

.audio-player audio {
  width: 100%;
  height: 40px;
}

.audio-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.875rem;
}

.audio-name {
  font-weight: 500;
}

.audio-duration {
  color: #9ca3af;
  font-variant-numeric: tabular-nums;
}
```

Integration points:
- CSS included in `toHTML()` output (embedded in `<style>` tag)
- CSS available as separate file for custom styling

**Acceptance Criteria:**
- [ ] Default CSS matches design mockup in `docs/design/audio-player.md`
- [ ] CSS renders correctly in Chrome, Firefox, Safari, Edge
- [ ] Example markdown files demonstrate audio player usage
- [ ] Example files successfully render (verified via integration test)
- [ ] Documentation updated with directive syntax and examples
- [ ] README mentions audio player feature
- [ ] Visual regression testing (manual) confirms design consistency
- [ ] Test coverage >80% line coverage (verified via cargo-llvm-cov)

---

## Cross-Cutting Concerns

### Testing Strategy

**Unit Tests:**
- Type construction and validation (Phase 1)
- Cache operations (get, upsert, hit/miss) (Phase 2)
- Metadata extraction with sample files (Phase 3)
- Audio processing pipeline logic (Phase 4)
- HTML generation and escaping (Phase 5)

**Integration Tests:**
- End-to-end: markdown → HTML with audio player (Phase 6)
- Cache persistence across multiple `render()` calls
- Inline vs file reference mode differences
- Error handling in full pipeline

**Property-Based Tests (Required):**
- Content hash stability (same input → same hash) - Phase 3
- HTML escaping completeness (no XSS vectors) - Phase 5

**Test Organization:**
- Unit tests in `#[cfg(test)] mod tests` within each module file
- Integration tests in `tests/integration/audio_*.rs`
- Sample audio files in `tests/fixtures/audio/` (small MP3/WAV files)

### Security Considerations

1. **Path Traversal Prevention:**
   - Validate that local file paths don't escape project directory
   - Canonicalize paths and check they start with allowed base path

2. **HTML Injection Prevention:**
   - Escape all user-controlled content (audio names, paths)
   - Use `html_escape()` for `src`, `display_name`

3. **Remote URL Fetching (Future):**
   - Validate URLs before fetching
   - Set request timeouts
   - Limit file size (e.g., max 100MB)
   - Use allowlist/blocklist for domains

4. **Cache Poisoning:**
   - Content hash prevents cache poisoning (hash mismatch → cache miss)

### Performance Considerations

1. **Caching:**
   - Metadata extraction cached by content hash
   - Avoids re-parsing unchanged audio files
   - RocksDB provides persistent, fast key-value storage

2. **Parallel Processing:**
   - When rendering multiple audio directives, use rayon to process in parallel
   - Each `process_audio()` call is independent (no shared state except cache)

3. **Lazy Loading:**
   - HTML5 `preload="metadata"` loads only metadata, not full audio initially
   - Reduces initial page load time

4. **File Copying vs Transcoding:**
   - Files copied as-is (no transcoding)
   - Avoids expensive encoding/decoding operations

5. **Base64 Trade-off:**
   - Inline mode increases HTML size by ~33%
   - Acceptable for small audio clips or portability requirements
   - Document this trade-off in user-facing documentation

### Logging and Observability

**Tracing Integration:**
- Use `#[instrument]` on `process_audio()`, `extract_audio_metadata()`
- Log cache hits/misses with `info!` level
- Log file copying operations with `debug!` level
- Log errors with `error!` level, including source and path context

**Span Structure:**
```rust
#[instrument(skip(cache), fields(source = ?input.source))]
pub fn process_audio(...) -> Result<AudioOutput> {
    info!(hash = %resource_hash, "Processing audio");
    // ...
    if cached.is_some() {
        info!(hash = %resource_hash, "Cache hit - using cached metadata");
    } else {
        info!(hash = %resource_hash, "Cache miss - extracting metadata");
    }
    // ...
}
```

## Parallelization Opportunities

All phases have sequential dependencies except:

| Parallel Group | Phases | Can Start After | Notes |
|----------------|--------|-----------------|-------|
| Group A | Phase 1 | Plan approval | Foundational types |
| Group B | Phase 2, Phase 3 | Phase 1 complete | Independent implementations |
| Group C | Phase 4 | Group B complete | Requires cache and metadata |
| Group D | Phase 5 | Phase 4 complete | Requires AudioOutput |
| Group E | Phase 6 | Phase 5 complete | Requires HTML generation |
| Group F | Phase 7 | Phase 6 complete | CSS and docs can be done in parallel with final testing |

**Key Insight:** Phase 2 (cache) and Phase 3 (metadata) can be developed in parallel after Phase 1 completes. This is the main parallelization opportunity.

## Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Symphonia metadata extraction fails for edge-case files | Medium | Low | Graceful degradation: use defaults for duration/bitrate if extraction fails; log warning |
| Base64 inline mode produces excessively large HTML | Medium | Medium | Document trade-off clearly; consider size warnings if audio > 10MB |
| Cache database corruption | High | Low | Use SurrealDB's transaction support; implement cache version migrations if schema changes |
| Unsupported audio formats (OGG, FLAC, AAC) requested by users | Low | Medium | Document supported formats; return clear error for unsupported formats; plan Phase 8 for additional formats |
| Remote URL fetching not implemented initially | Low | High | Document as "planned feature"; return clear error for remote URLs in Phase 3 |
| HTML/CSS rendering inconsistencies across browsers | Low | Low | Manual visual regression testing; provide CSS customization guidance |

## Open Questions

1. **Remote URL Fetching:** Should Phase 3 implement remote URL fetching, or defer to future work?
   - **Recommendation:** Defer to Phase 8 (future). Add `unimplemented!()` in `load_audio_bytes()` for remote URLs with clear error message.

2. **Cache Invalidation Strategy:** How should users invalidate stale cache entries?
   - **Recommendation:** Provide CLI command `compose cache clear --audio` to delete `audio_cache` table entries.

3. **Audio File Size Limits:** Should there be a max file size for inline mode or general processing?
   - **Recommendation:** Yes. Set max inline size to 10MB (log warning if exceeded). No limit for file reference mode.

4. **CSS Embedding Strategy:** Should CSS be embedded in every HTML output, or linked externally?
   - **Recommendation:** For `toHTML()` inline mode, embed CSS in `<style>` tag. For standard mode, emit separate `audio-player.css` file in output directory.

5. **Error Handling in Rendering:** If audio processing fails, should rendering fail or emit fallback HTML?
   - **Recommendation:** Emit fallback HTML with error message (e.g., `<div class="audio-error">Failed to load audio: {error}</div>`) and log error. Don't fail entire rendering.

## Review Summary

**Reviews Completed:** 2025-12-19

**Reviewers:**
- Rust Developer: Approve with Changes
- Feature Tester (Rust): Approve with Changes

**Overall Assessment:** Both reviewers approved the plan with recommended changes. The plan is solid and well-structured, with clear dependencies and parallelization opportunities. Key changes focus on alignment with existing codebase patterns, enhanced testing strategy, and better dependency management.

### Key Changes from Review

**Priority Changes (must address before Phase 1):**

1. **Error Type Location** - Use centralized error handling in `lib/src/error/mod.rs` instead of separate `lib/src/audio/error.rs`, following existing image module pattern
2. **Dependency Management** - Add `symphonia = { version = "0.5", features = ["mp3", "wav"] }` to `lib/Cargo.toml` dependencies in Phase 3
3. **SurrealDB Schema Location** - Add audio_cache table to existing `lib/src/cache/schema.rs` instead of separate migration
4. **Async/Sync Architecture** - Clarify async/sync boundaries: sync core processing functions with async public API wrappers (following image module pattern)

**Testing Enhancements:**

5. **Property-Based Testing** - Make mandatory for Phase 3 (content hash determinism)
6. **Snapshot Testing** - Add `insta` crate for Phase 5 HTML output verification
7. **Error Recovery Tests** - Add Phase 6 tests for corrupted files, missing files with `!`/`?` suffixes
8. **Duration Formatting Edge Cases** - Make explicit: test 0s→'0:00', 59s→'0:59', 60s→'1:00', 3661s→'61:01'
9. **XSS Prevention Tests** - Add Phase 5 tests for HTML escaping with malicious input
10. **Cache Persistence Tests** - Add integration test verifying cache survives DB reinit

**Security Additions:**

11. **Symlink Detection** - Add path validation to reject symlinks outside project scope
12. **MIME Type Validation** - Validate extension matches magic bytes (detect extension/content mismatch)
13. **Resource Limits** - Add `AudioProcessingConfig` with `max_file_size`, `max_inline_size`, `allowed_formats`

**Code Quality Enhancements:**

14. **Module Visibility** - Specify `pub` vs `pub(crate)` boundaries: only top-level API public
15. **Type Safety** - Use `#[non_exhaustive]` on `AudioFormat` for future compatibility
16. **Base64 Dependency** - Explicitly use existing `base64 = "0.22"` crate in Phase 4
17. **Test Fixtures** - Create minimal test fixtures (<50KB, 5s duration) with known metadata in Phase 1

**Optional Enhancements (defer to implementation):**

18. **Feature Flags** - Consider `[features] audio = ["dep:symphonia"]` for optional compilation
19. **Benchmarking** - Add criterion benchmarks for metadata extraction performance
20. **Fuzz Testing** - Add cargo-fuzz tests for malformed audio file resilience

### Resolved Concerns

| Concern | Resolution |
|---------|------------|
| Missing symphonia dependency | Add to Phase 3 deliverables and Cargo.toml |
| Error type placement inconsistency | Use centralized `lib/src/error/mod.rs` following image module pattern |
| Unclear async/sync boundaries | Document pattern: sync core, async API wrapper (matching image module) |
| Missing property tests | Make mandatory for Phase 3 (hash determinism) |
| Incomplete XSS testing | Add explicit tests for HTML escaping edge cases |
| Cache invalidation unclear | Document CLI command and add cache clear test |
| No parallel processing test | Add integration test for multiple audio directives |

### Implementation Notes

**Phase 1 Updates:**
- Add `AudioError` enum to `lib/src/error/mod.rs` (not separate file)
- Add minimal test fixtures to `tests/fixtures/audio/` (<50KB MP3/WAV with known metadata)
- Use `#[non_exhaustive]` on `AudioFormat` enum
- Add symlink detection test to `load_audio_bytes()` acceptance criteria

**Phase 2 Updates:**
- Add schema to existing `lib/src/cache/schema.rs`
- Add cache persistence integration test
- Add cache clear operation test

**Phase 3 Updates:**
- Add `symphonia = { version = "0.5", features = ["mp3", "wav"] }` to `lib/Cargo.toml`
- Make property test for hash determinism mandatory (not optional)
- Add test for extension/content mismatch validation
- Add test for corrupted/truncated audio files

**Phase 4 Updates:**
- Explicitly use `base64 = "0.22"` crate (already in dependencies)
- Add test for file size limit warning (>10MB in inline mode)
- Add `AudioProcessingConfig` for resource limits

**Phase 5 Updates:**
- Add `insta = "1"` to dev-dependencies for snapshot testing
- Add explicit XSS prevention tests with malicious input
- Make duration formatting tests explicit: 0s, 59s, 60s, 3661s, None

**Phase 6 Updates:**
- Add test for corrupted audio file → error HTML (not panic)
- Add test for directive parsing edge cases (quoted names, spaces, escaped quotes)
- Add integration test for multiple audio directives in same document

**Phase 7 Updates:**
- Add test coverage metric goal: >80% line coverage via cargo-llvm-cov
- Visual regression testing remains manual (acceptable for initial release)

## Next Steps After Plan Approval

1. **Execute Phase 1:** Implement core types and error handling (with priority changes applied)
2. **Execute Phases 2 & 3 in parallel:** Cache and metadata extraction (add symphonia dependency in Phase 3)
3. **Execute Phase 4:** Audio processing pipeline (add resource limits config)
4. **Execute Phase 5:** HTML generation (add snapshot tests with insta)
5. **Execute Phase 6:** Markdown parser integration (add error recovery tests)
6. **Execute Phase 7:** CSS and documentation (verify >80% coverage)
7. **Integration testing and manual verification**
8. **Update project roadmap with Phase 8 (future enhancements):**
   - Additional formats (OGG, FLAC, AAC)
   - Remote URL fetching
   - Waveform visualization
   - Playlist support
   - Timestamp/clip support
