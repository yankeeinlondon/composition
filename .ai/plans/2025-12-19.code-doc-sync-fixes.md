# Code-Documentation Sync Fixes

**Created:** 2025-12-19
**Status:** Reviewed - Ready for Implementation (with revisions)
**Last Updated:** 2025-12-19 (post-review)

## Executive Summary

Address 45 inconsistencies (14 Critical, 10 Major, 8 Minor) identified in code-documentation sync review. Focus areas: database schema documentation, utility variable implementation, gitignore filtering, breakpoint fixes, and documentation link repairs.

**Key Revision from Review:** Phase 3 (frontmatter refactor) has been REMOVED as current implementation is stable and well-tested. Focus redirected to critical security (gitignore) and UX improvements (utility variables, breakpoints).

## Requirements

### Functional Requirements

| ID | Requirement | Priority | Owner |
|----|-------------|----------|-------|
| FR-1 | Implement gitignore filtering for file resolution | High | Rust Developer |
| FR-2 | Implement utility frontmatter variables (14 variables) | High | Rust Developer |
| ~~FR-3~~ | ~~Refactor frontmatter parsing to use `markdown-frontmatter` crate~~ | ~~REMOVED~~ | ~~N/A~~ |
| FR-4 | Add `micro` (320px) breakpoint and fix `xs` usage | High | Rust Developer |
| FR-5 | Implement retina/HiDPI support (both 1x and 2x variants) | High | Rust Developer |
| FR-6 | Document all database schemas (6 tables, not 4) | High | Database Expert |
| FR-7 | Fix broken documentation links (3 locations) | Low | Rust Developer |
| FR-8 | Update documentation terminology ("master" → "root") | Low | Rust Developer |
| FR-9 | Create workspace Cargo.toml for monorepo | Medium | Rust Developer |
| ~~FR-10~~ | ~~Align Cargo edition to 2024~~ | ~~DEFERRED~~ | ~~Future work~~ |

### Non-Functional Requirements

| ID | Requirement | Target | Owner |
|----|-------------|--------|-------|
| NFR-1 | Security - gitignore filtering prevents sensitive file access | 100% coverage | Rust Developer |
| NFR-2 | Performance - image breakpoint generation remains parallel | No degradation | Rust Developer |
| NFR-3 | Compatibility - maintain existing API surface | Zero breaking changes | Rust Developer |
| NFR-4 | Documentation accuracy | 100% code-doc sync | Database Expert |

## Architecture Overview

This plan addresses implementation gaps and documentation deficits without changing the fundamental architecture. Key areas:

1. **File Resolution Layer** - Add gitignore filtering using `ignore` crate with caching
2. **Frontmatter Layer** - Add utility variables (14 variables) to interpolation system
3. **Image Processing** - Fix breakpoints (add `micro`, clarify `xs`) and implement retina with 1x+2x variants
4. **Database Layer** - Document all 6 existing schemas (no code changes needed)
5. **Documentation** - Fix links and terminology mismatches

**Architectural Changes from Review:**
- Phase 3 (frontmatter refactor) REMOVED - current `yaml-rust2` implementation is stable
- Phase 7 edition migration DEFERRED - not critical for sync fixes, defer to future work
- Phase 1 gitignore implementation uses `Gitignore` directly with lazy caching, not `WalkBuilder`
- Phase 4 retina generates BOTH 1x and 2x variants for optimal multi-DPI support

### Component Diagram

```
┌─────────────────────────────────────────────────────────┐
│                     API Surface                          │
│  init() → graph() → generateWorkplan() → render()       │
└─────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
        ▼                   ▼                   ▼
┌──────────────┐   ┌──────────────┐   ┌──────────────┐
│ File Resolver│   │  Frontmatter │   │Image Processor│
│  +gitignore  │   │  +utilities  │   │  +retina 2x  │
│   filtering  │   │  +refactor   │   │ +xs/micro BP │
└──────────────┘   └──────────────┘   └──────────────┘
        │                   │                   │
        └───────────────────┼───────────────────┘
                            ▼
                    ┌──────────────┐
                    │  SurrealDB   │
                    │  (document   │
                    │  schemas)    │
                    └──────────────┘
```

### Data Flow

No changes to core data flow. Enhancements:
- File resolution adds `.gitignore` check before loading
- Frontmatter parsing adds utility variable injection
- Image processing generates additional breakpoint variants

## Phases

### Phase 1: Gitignore Filtering Implementation

**Principal Owner:** Rust Developer

**Goal:** Prevent sensitive files (.env, node_modules/, etc.) from being transcluded by implementing gitignore-aware file resolution.

**Dependencies:** None

**Blast Radius:** `lib/tests/**/*.rs` (all tests - core file resolution affects everything)

**Deliverables:**
- Add `ignore` crate dependency to `lib/Cargo.toml`
- Create `lib/src/graph/gitignore.rs` module
- Integrate filtering into `lib/src/graph/utils.rs::resolve_local_file()`
- Unit tests for gitignore patterns
- Integration test ensuring `.env` files are rejected

**Technical Details:**

Files to modify:
- `lib/Cargo.toml` - Add `ignore = "0.4"` dependency
- `lib/src/graph/utils.rs` - Add gitignore check before file read
- `lib/src/graph/mod.rs` - Export gitignore module
- `lib/src/error/mod.rs` - Add `FileIgnored` error variant

Key function changes:
```rust
// In lib/src/graph/utils.rs
pub fn resolve_local_file(path: &Path, project_root: &Path) -> Result<String> {
    // NEW: Check gitignore before reading
    if is_ignored_by_gitignore(path, project_root)? {
        return Err(GraphError::FileIgnored(path.display().to_string()));
    }

    // Existing file read logic...
}
```

Integration approach:
- Use `ignore::WalkBuilder` to create gitignore matcher
- Cache gitignore rules per project root (avoid re-parsing)
- Honor `.gitignore`, `.git/info/exclude`, and global gitignore

**Acceptance Criteria:**
- [ ] Files matching `.gitignore` patterns return `FileIgnored` error
- [ ] `.env`, `node_modules/**`, `.git/**` are rejected
- [ ] Files explicitly tracked by git are allowed even if gitignored
- [ ] Performance impact < 5ms per file resolution
- [ ] Unit tests cover common gitignore patterns
- [ ] Integration test verifies security protection

---

### Phase 2: Utility Frontmatter Variables

**Principal Owner:** Rust Developer

**Goal:** Implement 14 utility variables (today, yesterday, season, etc.) that are always available for interpolation.

**Dependencies:** None (can run parallel with Phase 1)

**Blast Radius:** `lib/tests/unit/**/interpolation*.rs` (interpolation and frontmatter tests)

**Deliverables:**
- Add utility variable generation in `lib/src/render/interpolation.rs`
- Inject utilities before custom frontmatter variables
- Unit tests for all 14 utilities
- Update `docs/reference/utility-frontmatter.md` examples

**Technical Details:**

Files to modify:
- `lib/src/render/interpolation.rs` - Add `generate_utility_variables()` function
- `lib/src/types/frontmatter.rs` - Add utilities to Frontmatter struct

Utility variables to implement:
1. `{{today}}` - YYYY-MM-DD
2. `{{yesterday}}` - YYYY-MM-DD
3. `{{tomorrow}}` - YYYY-MM-DD
4. `{{year}}` - YYYY
5. `{{month}}` - MM
6. `{{day}}` - DD
7. `{{season}}` - spring/summer/fall/winter (Northern Hemisphere)
8. `{{day_of_week}}` - Monday/Tuesday/etc
9. `{{week_number}}` - ISO week number
10. `{{timestamp}}` - Unix timestamp
11. `{{iso_timestamp}}` - ISO 8601
12. `{{now_utc}}` - UTC time string
13. `{{now_local}}` - Local time string
14. `{{timezone}}` - Current timezone

Implementation pattern:
```rust
pub fn generate_utility_variables() -> HashMap<String, serde_json::Value> {
    let now = chrono::Local::now();
    let mut vars = HashMap::new();

    vars.insert("today".to_string(), json!(now.format("%Y-%m-%d").to_string()));
    vars.insert("year".to_string(), json!(now.year().to_string()));
    // ... all 14 variables

    vars
}

// In process_interpolation()
pub fn process_interpolation(content: &str, frontmatter: &Frontmatter) -> Result<String> {
    let utilities = generate_utility_variables();

    // Merge: custom frontmatter overrides utilities
    let all_vars = utilities.into_iter()
        .chain(frontmatter.custom.clone())
        .collect::<HashMap<_, _>>();

    // Existing interpolation logic using all_vars...
}
```

**Acceptance Criteria:**
- [ ] All 14 utility variables render correctly
- [ ] Custom frontmatter variables override utilities
- [ ] `{{today}}` matches system date
- [ ] `{{season}}` calculates correctly for all months
- [ ] No breaking changes to existing interpolation behavior
- [ ] Unit tests for each utility variable
- [ ] Documentation includes examples

---

### Phase 3: Frontmatter Parsing Refactor

**Principal Owner:** Rust Developer

**Goal:** Replace custom YAML parsing with `markdown-frontmatter` crate for better maintainability.

**Dependencies:** None (can run parallel with Phase 1 & 2, but merge last)

**Blast Radius:** `lib/tests/**/frontmatter*.rs, lib/tests/integration/**/*.rs` (frontmatter affects entire pipeline)

**Deliverables:**
- Add `markdown-frontmatter` crate dependency
- Refactor `lib/src/parse/frontmatter.rs` to use new crate
- Remove `yaml-rust2` dependency (if not used elsewhere)
- Maintain 100% compatibility with existing frontmatter tests
- Update error handling for new crate's error types

**Technical Details:**

Files to modify:
- `lib/Cargo.toml` - Add `markdown-frontmatter = "0.4"`, potentially remove `yaml-rust2`
- `lib/src/parse/frontmatter.rs` - Complete refactor
- `lib/src/error/mod.rs` - Update error types for new crate

Refactor approach:
```rust
use markdown_frontmatter::{parse, Value};

pub fn extract_frontmatter(content: &str) -> Result<(Frontmatter, &str), ParseError> {
    let result = parse(content)
        .map_err(|e| ParseError::FrontmatterParse(e.to_string()))?;

    if let Some(yaml) = result.frontmatter {
        let frontmatter = yaml_value_to_frontmatter(&yaml)?;
        Ok((frontmatter, result.content))
    } else {
        Ok((Frontmatter::default(), content))
    }
}
```

Migration considerations:
- `markdown-frontmatter` handles delimiter parsing automatically
- More robust edge case handling (empty frontmatter, missing closing delimiter)
- Better error messages for malformed YAML
- Must maintain exact same API surface for Frontmatter struct

**Acceptance Criteria:**
- [ ] All existing frontmatter tests pass unchanged
- [ ] Custom fields still populate `frontmatter.custom` HashMap
- [ ] Known frontmatter fields (list_expansion, replace, breakpoints) still populate dedicated fields
- [ ] Error messages are equally informative
- [ ] No performance regression (benchmark against current implementation)
- [ ] Code is more maintainable (< 100 lines vs current 180+ lines)

---

### Phase 4: Breakpoint Fixes (xs/micro + Retina)

**Principal Owner:** Rust Developer

**Goal:** Add missing `xs` (640px) and `micro` (320px) breakpoints, implement retina/HiDPI support (2x width multiplier).

**Dependencies:** None (can run parallel with Phase 1-3)

**Blast Radius:** `lib/tests/**/image*.rs` (image processing tests)

**Deliverables:**
- Add `Micro` and `Xs` variants to `Breakpoint` enum
- Update `BREAKPOINTS` constant with 7 breakpoints (micro, xs, sm, md, lg, xl, xxl)
- Modify image processing to double breakpoint values for retina
- Update HTML generation to include new breakpoint sizes
- Unit tests for new breakpoints
- Snapshot tests for updated HTML output

**Technical Details:**

Files to modify:
- `lib/src/types/mod.rs` or `lib/src/types/breakpoint.rs` - Add enum variants
- `lib/src/image/mod.rs` - Update BREAKPOINTS constant
- `lib/src/image/processing.rs` - Implement retina width doubling
- `lib/src/image/html.rs` - Update srcset generation
- `docs/reference/breakpoints.md` - Document all 7 breakpoints

Enum update:
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Breakpoint {
    Micro,  // NEW
    Xs,     // NEW
    Sm,
    Md,
    Lg,
    Xl,
    Xxl,
}
```

Breakpoints constant update:
```rust
pub const BREAKPOINTS: &[(Breakpoint, u32)] = &[
    (Breakpoint::Micro, 320),  // NEW - mobile portrait
    (Breakpoint::Xs, 640),     // NEW - mobile landscape
    (Breakpoint::Sm, 640),     // Tailwind default
    (Breakpoint::Md, 768),
    (Breakpoint::Lg, 1024),
    (Breakpoint::Xl, 1280),
    (Breakpoint::Xxl, 1536),
];
```

Retina implementation:
```rust
// In lib/src/image/processing.rs
pub fn process_image(img: &DynamicImage, opts: &ImageOptions) -> Vec<ImageVariant> {
    BREAKPOINTS.par_iter().filter_map(|(bp, base_width)| {
        // CHANGE: Double for retina
        let target_width = base_width * 2;  // 2x for HiDPI displays

        if let Some(max) = opts.max_width {
            if target_width > max { return None; }
        }

        let resized = resize_image(img, target_width);
        // ... encode variant
    }).collect()
}
```

HTML generation update:
```rust
// srcset should reference breakpoint names
<source
  type="image/avif"
  srcset="data:image/avif;base64,{xs_avif} 640w,
          data:image/avif;base64,{sm_avif} 1280w,  // 2x retina
          data:image/avif;base64,{md_avif} 1536w"  // 2x retina
/>
```

**Acceptance Criteria:**
- [ ] `Micro` and `Xs` breakpoints generate 320px and 640px images
- [ ] All breakpoints generate images at 2x width for retina displays
- [ ] Largest image is 3072px (1536 * 2) for xxl breakpoint
- [ ] HTML srcset attributes correctly reference widths
- [ ] Existing tests updated with new breakpoint expectations
- [ ] Mobile users benefit from smaller initial downloads
- [ ] Retina displays receive high-quality images

---

### Phase 5: Database Schema Documentation

**Principal Owner:** Database Expert

**Goal:** Document all existing database schemas in `docs/reference/database.md` - no code changes needed.

**Dependencies:** None

**Blast Radius:** `` (empty - documentation only, no tests needed)

**Deliverables:**
- Complete documentation of `document` table (5 fields + 1 index)
- Complete documentation of `depends_on` edge table (4 fields)
- Complete documentation of `image_cache` table (10 fields + 2 indexes)
- Complete documentation of `llm_cache` table (7 fields + 2 indexes)
- Complete documentation of `embedding` table (6 fields + 1 index)
- Complete documentation of `audio_cache` table (9 fields + 2 indexes)
- Document database location resolution logic
- Document RocksDB backend choice and rationale

**Technical Details:**

Files to modify:
- `docs/reference/database.md` - Replace all "TBD" sections with actual schema

Documentation structure:
```markdown
## Document Map Schema

### `document` Table

**Purpose:** Graph nodes representing markdown documents.

| Field | Type | Description |
|-------|------|-------------|
| resource_hash | string | xxHash of resource identifier (file path or URL) |
| content_hash | string | xxHash of actual content |
| file_path | option<string> | Path for local files |
| url | option<string> | URL for remote resources |
| last_validated | datetime | Last cache validation timestamp |

**Indexes:**
- `idx_resource_hash` - UNIQUE on resource_hash for fast lookups

**Graph Relations:**
- Connected via `depends_on` edges using SurrealDB RELATE syntax

### `depends_on` Table

**Purpose:** Graph edges representing document dependencies.

| Field | Type | Description |
|-------|------|-------------|
| in | record<document> | Source document |
| out | record<document> | Target document |
| reference_type | string | transclusion/summarize/consolidate |
| required | bool | Error if missing (! suffix) vs silent skip (?) |

[... continue for all 6 tables ...]

## Backend Technology

**Database:** SurrealDB
**Backend:** RocksDB (persisted to disk)

**Why RocksDB?**
- Persistent storage (survives process restarts)
- High performance for read-heavy workloads
- Efficient key-value lookups for cache operations
- Supports transactions for graph consistency

## Database Location Resolution

The database file location is determined by `locate_database_path()`:

1. **Git repository detected:** `{repo_root}/.composition.db`
2. **Explicit start_dir provided:** `{start_dir}/.composition.db`
3. **Fallback:** `$HOME/.composition.db`

[... continue with all sections ...]
```

**Acceptance Criteria:**
- [ ] All 6 tables fully documented
- [ ] No "TBD" sections remain
- [ ] Schema matches `lib/src/cache/schema.rs` exactly
- [ ] Database backend (RocksDB) explained
- [ ] Location resolution logic documented with examples
- [ ] Developers can understand schema without reading Rust code

---

### Phase 6: Documentation Link Fixes

**Principal Owner:** Rust Developer

**Goal:** Fix 3 broken documentation links and update terminology mismatches.

**Dependencies:** None

**Blast Radius:** `` (empty - documentation only, no tests needed)

**Deliverables:**
- Fix broken caching.md reference
- Fix incorrect relative path in hashing.md
- Fix broken anchor reference in lsp-features.md
- Update "master document" → "root" terminology
- Update pulldown-cmark version reference (0.10 → 0.13)
- Update tech-stack.md to reflect actual crate usage

**Technical Details:**

Files to modify:
- `docs/walking-document-tree.md` - Update "master" → "root", fix caching.md link
- `docs/reference/hashing.md` - Fix relative path to skill document
- `docs/features/lsp-features.md` - Fix anchor reference
- `docs/design/lsp-technical-strategy.md` - Update pulldown-cmark version
- `docs/reference/tech-stack.md` - Remove mentions of unused crates (zune-image, markdown-frontmatter if removed in Phase 3)

Specific fixes:

1. **docs/walking-document-tree.md:9**
   ```markdown
   - [caching strategy](./caching.md)  ❌ Broken
   + [caching strategy](./design/cache-strategy.md)  ✅ Fixed

   - master document  ❌ Wrong term
   + root document    ✅ Matches code
   ```

2. **docs/reference/hashing.md:3**
   ```markdown
   - [xxHash skill](../.claude/skills/xx-hash/SKILL.md)  ❌ Wrong depth
   + [xxHash skill](../../.claude/skills/xx-hash/SKILL.md)  ✅ Or use repo-relative: `.claude/skills/xx-hash/SKILL.md`
   ```

3. **docs/features/lsp-features.md:21**
   ```markdown
   - [interpolation](darkmatter-dsl.md#11-frontmatter-interpolation)  ❌ Anchor doesn't exist
   + [interpolation](../reference/utility-frontmatter.md)  ✅ Correct document
   ```

4. **docs/design/lsp-technical-strategy.md:61**
   ```markdown
   - pulldown-cmark version 0.10  ❌ Old version
   + pulldown-cmark version 0.13  ✅ Matches Cargo.toml
   ```

5. **docs/reference/tech-stack.md**
   - Remove mention of `markdown-frontmatter` (contradicts current yaml-rust2 usage)
   - Remove mention of `zune-image` (only `image` crate is used)
   - Update OpenTelemetry section to note it's planned but not yet implemented

**Acceptance Criteria:**
- [ ] All internal markdown links resolve correctly
- [ ] Terminology is consistent between docs and code
- [ ] Version numbers match actual dependencies
- [ ] No references to unused crates in tech stack

---

### Phase 7: Workspace & Edition Alignment

**Principal Owner:** Rust Developer

**Goal:** Create workspace Cargo.toml and align all modules to edition 2024.

**Dependencies:** None (but should run after Phase 1-4 to avoid merge conflicts)

**Blast Radius:** `lib/tests/**/*.rs, cli/tests/**/*.rs` (all tests - Cargo workspace affects builds)

**Deliverables:**
- Create `Cargo.toml` workspace manifest at repository root
- Update `lib/Cargo.toml` edition to "2024"
- Update `cli/Cargo.toml` edition to "2024" (already done)
- Verify all tests pass with edition 2024
- Document any edition 2024 migration notes

**Technical Details:**

Files to create:
- `Cargo.toml` (root) - New workspace manifest

Files to modify:
- `lib/Cargo.toml` - Change edition to "2024", add workspace reference
- `cli/Cargo.toml` - Add workspace reference (edition already "2024")

Workspace manifest structure:
```toml
[workspace]
members = ["lib", "cli", "lsp"]
resolver = "2"

[workspace.package]
edition = "2024"
authors = ["Ken Snyder"]
license = "MIT"

[workspace.dependencies]
# Shared dependencies across modules
pulldown-cmark = "0.13.0"
thiserror = "2.0.17"
tokio = { version = "1", features = ["full"] }
surrealdb = { version = "1.5", features = ["kv-rocksdb", "kv-mem"] }
rayon = "1.10"
xxhash-rust = { version = "0.8", features = ["xxh3"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

Edition 2024 considerations:
- Rust 2024 edition is very new (requires rustc 1.85+)
- Check for breaking changes in edition guide
- Likely minimal impact (mostly linting and new features)
- Gen keyword becomes reserved (check for usage)

**Acceptance Criteria:**
- [ ] `cargo build` succeeds from workspace root
- [ ] `cargo test` runs all module tests from root
- [ ] All modules use edition "2024"
- [ ] Dependency resolution is faster (workspace benefit)
- [ ] No edition-related compilation errors
- [ ] CI builds pass with new workspace structure

---

## Cross-Cutting Concerns

### Testing Strategy

- **Unit tests:** Each phase includes unit tests for new functionality
- **Integration tests:** Phase 1 (gitignore), Phase 3 (frontmatter), Phase 4 (image processing) require integration tests
- **Snapshot tests:** Phase 4 (image HTML generation) uses insta snapshots
- **Regression tests:** All existing tests must pass to ensure no breaking changes

### Security Considerations

- **Phase 1 (Gitignore)** is critical security fix - prevents `.env`, credentials, etc. from being transcluded
- Must verify gitignore filtering cannot be bypassed
- Test with malicious paths (../../../.env, symlinks, etc.)

### Performance Considerations

- **Phase 1:** Gitignore check adds minimal overhead (<5ms per file)
- **Phase 2:** Utility variable generation is one-time per document parse
- **Phase 3:** `markdown-frontmatter` should be same or better performance than yaml-rust2
- **Phase 4:** Additional breakpoints increase processing time (2 more variants) but benefit mobile users

## Parallelization Opportunities

**UPDATED POST-REVIEW:** Phases 3 and 7 removed/deferred, simplifying parallelization.

All remaining phases can execute in parallel as they modify independent subsystems:

| Parallel Group | Phases | Reason |
|----------------|--------|--------|
| **Group A** | Phase 1, 2, 4, 5, 6 | Independent modules/files - no conflicts |
| **Group B** | Phase 7 (Workspace) | DEFERRED to future work |

### Parallelization Diagram

```text
Timeline (REVISED):
──────────────────────────────────►

Group A: ████████████████ (Phases 1, 2, 4, 5, 6 in parallel - ALL EXECUTE TOGETHER)
```

### Synchronization Points

1. **After Group A:** All phases complete
   - Run full test suite: `cargo test --workspace`
   - Verify no regressions
   - Final integration testing

**SIMPLIFIED:** No sequential dependencies between phases. All can start simultaneously.

## Risk Assessment

**UPDATED POST-REVIEW:** Risks significantly reduced by removing Phase 3 and deferring Phase 7.

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Gitignore filtering too aggressive** | Medium | Test with git-tracked files to ensure allowed; add `--no-gitignore` override flag if needed |
| **Gitignore caching memory leak** | Low | Use `lazy_static` with bounded cache size (LRU eviction if >100 projects) |
| **Retina bandwidth increase** | Low | Generate both 1x and 2x; browser chooses appropriate variant via srcset |
| **Breakpoint enum/constant mismatch** | High | Audit existing `Breakpoint::Xs` usage before adding `Micro`; ensure consistency |
| **Utility variable timezone inconsistency** | Low | Document that `{{timezone}}` returns offset format; avoid platform-specific IANA names |
| **Database doc comprehensiveness** | Medium | Database Expert must extract ALL schema details from `schema.rs` and `operations.rs` |

## Open Questions

**UPDATED POST-REVIEW:** Several questions resolved by review process.

- [x] **Q1:** Should gitignore filtering be optional (config flag) or always enforced?
  - **RESOLVED:** Always enforce for security; implementation may add `--no-gitignore` flag if edge cases emerge

- [x] **Q2:** Should utility variables be overridable by custom frontmatter, or always take precedence?
  - **RESOLVED:** Custom frontmatter overrides utilities (user control) - implement with merge order

- [x] **Q3:** For retina images, should we generate both 1x and 2x, or only 2x?
  - **RESOLVED:** Generate BOTH 1x and 2x variants; browser selects via srcset based on DPI

- [x] **Q4:** Should we keep `yaml-rust2` dependency after adding `markdown-frontmatter`?
  - **RESOLVED:** Phase 3 REMOVED - keep current `yaml-rust2` implementation (stable and tested)

- [x] **Q5:** Should edition 2024 migration include LSP module (not yet implemented)?
  - **RESOLVED:** Phase 7 DEFERRED entirely - edition migration not part of sync fixes

- [x] **Q6:** Should Phase 5 (database docs) include ER diagram or just tables?
  - **RESOLVED:** YES - ASCII ER diagram required showing document → depends_on → document relationships

**New Questions from Review:**

- [ ] **Q7:** Should `Breakpoint::Xs` enum variant be kept at current 0px or updated to 640px?
  - **Research needed:** Audit existing code usage of `Xs` variant before Phase 4 implementation

- [ ] **Q8:** Should gitignore caching be bounded (LRU eviction) or unbounded?
  - **Recommendation:** Start unbounded, add LRU if memory issues emerge (unlikely in typical usage)

- [ ] **Q9:** Should Phase 5 document query performance characteristics (indexes, slow query examples)?
  - **Recommendation:** Yes - Database Expert should include performance section with common query patterns

---

## Review Summary

**Reviews Completed:** 2025-12-19

**Reviewers:**
- **Rust Developer:** Approve with Changes
- **Database Expert:** Approve with Changes  
- **Feature Tester (Rust):** Approve with Changes

### Key Changes from Review

1. **Phase 3 (Frontmatter Refactor) REMOVED**
   - Current `yaml-rust2` implementation is stable, tested, and maintainable (180 lines)
   - `markdown-frontmatter` crate is less actively maintained (2+ years since update)
   - No performance or functionality benefit from switching
   - **Impact:** Reduced risk, simplified parallelization

2. **Phase 7 (Edition 2024 + Workspace) DEFERRED**
   - Edition migration not critical for code-doc sync fixes
   - Workspace structure beneficial but separate initiative
   - Rust 2024 edition very recent (1.85.1) - ecosystem may have compatibility issues
   - **Impact:** Defer to future work, focus on critical fixes

3. **Phase 1 Implementation Approach Refined**
   - Use `ignore::gitignore::Gitignore` directly, NOT `WalkBuilder`
   - Add lazy caching with `lazy_static` or `once_cell`
   - Performance target <5ms achievable with proper caching
   - **Impact:** Better performance, cleaner architecture

4. **Phase 4 Breakpoint Strategy Clarified**
   - Generate BOTH 1x AND 2x variants (not just 2x)
   - Fix discovered issue: `Breakpoint::Xs` exists in enum but not in BREAKPOINTS constant
   - Audit required: Determine if `Xs` should be 640px or if `Micro` is sufficient
   - **Impact:** Better multi-DPI support, need code audit before implementation

5. **Phase 5 Documentation Scope Expanded**
   - Must document all 6 tables (not 4): document, depends_on, image_cache, llm_cache, embedding, audio_cache
   - Must include ER diagram showing graph relationships
   - Must document database location resolution logic
   - Must include query performance notes
   - **Impact:** More comprehensive documentation deliverable

6. **Testing Requirements Strengthened**
   - Phase 1: Add security tests (symlinks, malicious paths, git-tracked gitignored files)
   - Phase 2: Add precedence tests (custom frontmatter overrides utilities)
   - Phase 4: Update all snapshot tests with `cargo insta review`
   - All phases: Ensure blast radius correctly identifies affected tests
   - **Impact:** Higher quality implementation, fewer bugs

### Resolved Concerns

**Rust Developer Concerns:**

- **Gitignore implementation complexity** → Use `Gitignore` directly with caching (not `WalkBuilder`)
- **Utility timezone handling** → Document that `{{timezone}}` returns offset format (e.g., "+00:00")
- **Frontmatter refactor risk** → Phase 3 REMOVED entirely
- **Breakpoint duplication** → Audit `Xs` usage, fix enum/constant mismatch
- **Retina oversimplification** → Generate both 1x and 2x variants
- **Edition 2024 timing** → Phase 7 DEFERRED to future work

**Database Expert Concerns:**

- **Missing schema documentation** → Phase 5 deliverables expanded to cover all 6 tables
- **Incomplete indexes** → Noted for future optimization (not blocking sync fixes)
- **Schema evolution strategy** → Added placeholder section for future versioning
- **Cache invalidation edge cases** → Documented current behavior, no code changes needed
- **Database location resolution** → Added to Phase 5 required documentation

**Feature Tester Concerns:**

- **Gitignore testing gaps** → Added security test scenarios (symlinks, path traversal, nested .gitignore)
- **Utility variable interaction tests** → Added precedence tests and timezone boundary tests
- **Breakpoint snapshot updates** → Added `cargo insta review` to Phase 4 acceptance criteria
- **Blast radius accuracy** → Verified all phases have correct test scope
- **Property-based testing** → Recommended for Phase 2 (utility variables determinism)

### Implementation Priorities

**Critical Path (Must Complete):**
1. Phase 1 (Gitignore) - Security fix
2. Phase 5 (Database docs) - Unblocks developer understanding
3. Phase 6 (Doc link fixes) - Prevents broken references

**High Value (Should Complete):**
4. Phase 2 (Utility variables) - User-facing feature
5. Phase 4 (Breakpoints + Retina) - UX improvement for mobile/retina users

**All phases can execute in parallel - no dependencies between them.**

### Success Metrics

- [ ] All 45 documented inconsistencies addressed or documented as deferred
- [ ] Zero breaking changes to existing API
- [ ] All 232 existing unit tests pass
- [ ] New tests added for gitignore security, utility variables, breakpoints
- [ ] Documentation 100% accurate to implementation
- [ ] No performance regression (<5ms overhead for gitignore, no image processing slowdown)

---

## Next Steps

1. **User approval** of revised plan
2. **Code audit** for `Breakpoint::Xs` usage (resolve Q7)
3. **Parallel execution** of Phases 1, 2, 4, 5, 6
4. **Final integration testing** after all phases complete
5. **Future work:** Phase 7 (workspace + edition 2024) as separate initiative
