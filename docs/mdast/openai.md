---
_fixed: true
---

# Markdown AST Ecosystems: TypeScript vs Rust

A technical comparison of the TypeScript (MDAST via Unified/Remark) and Rust (markdown-rs) ecosystems for Markdown abstract syntax tree processing.

## TypeScript Ecosystem (MDAST via Unified/Remark)

The TypeScript/JavaScript MDAST ecosystem centers around the Unified framework and its Markdown processor Remark, which together provide a powerful pipeline for parsing, transforming, and serializing Markdown. In this ecosystem, Markdown text is first parsed into an MDAST (Markdown Abstract Syntax Tree) using remark-parse (which implements the mdast specification). This AST can then be analyzed or transformed by various Remark plugins, and finally converted to output (such as HTML) by passing through Rehype (HTML processor) and serializing to a string.

### Core Libraries and Workflow

The typical flow uses Unified to chain plugins: for example, to get HTML one might do `unified().use(remarkParse).use(...plugins...).use(remarkRehype).use(rehypeStringify)`. Here remark-parse produces an MDAST from markdown, plugins can modify the AST, then remark-rehype converts it to an HTML AST (HAST), and rehype-stringify outputs HTML. Remark's parser is fully CommonMark-compliant, and with plugins it also supports GitHub Flavored Markdown (GFM) and MDX extensions. In fact, Remark advertises 100% compliance with CommonMark and GFM (or MDX) when the appropriate plugins are used. The AST nodes adhere to the mdast spec (built on unified's base unist format), which includes all standard Markdown elements (paragraph, heading, list, etc.) and optional extensions for GFM (tables, footnotes, strikethrough, task lists) and MDX nodes.

### Plugins and Extensions

A major strength of the TS ecosystem is its rich plugin ecosystem and extensibility. Remark itself is "an ecosystem of plugins" – over 150 plugins are available for everything from linting to content transformation. Plugins can inspect or change the AST (e.g. adding or removing nodes, modifying text) or even introduce new syntax. For example, remark-gfm enables GFM syntax (tables, task lists, etc.), remark-frontmatter parses YAML frontmatter into AST nodes, and remark-math with rehype-katex will render LaTeX formulas. Advanced use-cases like MDX (Markdown with JSX) are supported via plugins like remark-mdx which extend the parser to recognize MDX syntax (JSX tags, import/export statements, etc.). The remark-mdx plugin works in conjunction with the MDX compiler (@mdx-js/mdx) to ultimately convert MDX to JSX/React code. In practice, MDX v2 uses Remark under the hood for parsing, then compiles the enriched AST to JavaScript/React; Remark's MDX plugin simply allows the MDAST to include MDX-specific node types (such as mdxJsxTextElement for inline JSX). Notably, MDX parsing in this ecosystem provides diagnostics for syntax errors – since MDX embeds JavaScript, the plugin uses the Acorn JS parser to report issues with JSX or expressions, including line/column info (similar to how markdown-rs reports MDX errors, discussed later).

### Linting and Diagnostics

The TypeScript ecosystem offers robust linting through remark-lint, which is a collection of plugins that analyze the MDAST for style or consistency issues. There are around 70 rule plugins (e.g. check for heading increment, list indentation, prohibited terms, etc.) and preset configurations (like remark-preset-lint-recommended). These lint rules run as remark plugins, inspecting the AST for patterns and adding vfile messages (warnings or errors with positional info). For example, remark-lint can warn about inconsistent list markers or incorrect emphasis markers, with detailed positions. Because the AST nodes in both Remark and Rehype include position data, diagnostic messages can point to exact locations in the source. Aside from style linting, plugins exist for other diagnostics – e.g. remark-validate-links checks that links/images point to existing targets. If the Markdown has parsing issues (which in pure Markdown is rare since CommonMark defines graceful behavior for most cases), Remark usually still produces an AST node (for example, an unmatched `]` in a link might just be treated as literal text). However, for MDX, parse errors (like malformed JSX) will throw an error with location. The MDX plugin documentation notes it doesn't itself compile to HTML; instead, one would either use rehype to pass MDX nodes through (treating them as opaque) or use the MDX compiler to get a React component.

### HTML Conversion and Output

For standard Markdown-to-HTML, the Remark/Rehype pipeline is straightforward and highly customizable. By converting MDAST to HAST (HTML AST), users can plug in rehype plugins (which operate on HTML AST) for tasks like syntax highlighting, sanitization, or SEO enhancements. For example, using rehype-highlight in the chain will perform code block syntax highlighting. Finally, rehype-stringify serializes the AST to an HTML string. Remark also has a compiler to serialize back to Markdown (remark-stringify) in case you want to modify Markdown programmatically and save it. This makes round-tripping possible (Markdown → AST → modified AST → Markdown). Moreover, since unified's data model is abstract, one could write custom compilers (e.g. output JSON or other formats). Indeed, the unified ecosystem has processors beyond markdown: e.g. retext for natural language AST and rehype for HTML, so theoretically one can pipe from one format to another (markdown → HTML → etc.) if needed. In practice, Remark is often used in static site generators and editors (e.g. Gatsby and Docusaurus use Remark/MDX for MD content, VS Code Markdown features use similar AST tooling).

### Extensibility and Composability

The JS ecosystem is extremely extensible. Developers can create new remark plugins to support custom syntax or DSLs within Markdown. For example, if you have a custom directive like `:::warning ... :::` for admonitions, you can write a plugin to parse that into a new AST node and later render it as a special HTML block. Remark's parsing is powered by micromark, a highly compliant CommonMark tokenizer, which can be extended with syntax extensions. The unified team provides lower-level utilities (micromark extension APIs and mdast utilities) to define custom syntax. This means one can implement new Markdown features by hooking into the tokenizer and defining how it produces AST nodes – many remark plugins do exactly this (e.g. mdast-util-math adds support for `$...$` math syntax). As a result, the composability is excellent: multiple plugins can be composed in sequence to handle different concerns. For instance, you could use a plugin to include external files (remark-include), then a plugin to transform a custom macro syntax, then pass to rehype to handle raw HTML or perform sanitation. Composing separate markdown files is often handled at a higher level (outside of remark), but there are plugins that allow including one Markdown into another (though not part of core). In discussions, maintainers often suggest using MDX or other mechanisms for "including" content, since MDX allows importing one file into another as a module. Nevertheless, it's feasible to merge ASTs manually (each Markdown file yields a Root node – a developer can concatenate the children arrays of multiple roots).

### Performance Characteristics

The JavaScript/TypeScript MDAST ecosystem prioritizes flexibility and richness over raw speed. In terms of performance, Remark (with plugins) is not the fastest parser – it incurs overhead from building the AST and running many plugins in JS. Lighter JS parsers like marked or markdown-it can outperform remark in pure parsing speed. For example, in one benchmark a large 7,600-line markdown file was parsed significantly faster by marked than by a Remark+rehype pipeline. However, Remark's advantage is that it can do much more in one pass (linting, transforming, etc.). The unified team has improved performance over time (the introduction of micromark in lieu of the old Remark parser improved speed and CommonMark compliance). Still, compared to native implementations, JS will be slower. Many applications mitigate this by caching results (since content changes less often than it's read) or by offloading heavy work to build time. It's worth noting that remark is considered the "world's most popular" Markdown processor in the JS ecosystem, and its performance is generally acceptable for typical content sizes. For extremely large Markdown or CPU-constrained environments, alternatives (or leveraging Rust via WASM) are considered – which is one motivation behind the Rust ecosystem developments.

## Rust Ecosystem (Markdown-RS and Tools)

The Rust Markdown AST ecosystem is newer and currently revolves around the markdown-rs crate (often just called markdown on crates.io). This project, created by Titus Wormer (author of Remark) and funded initially by Vercel, aims to bring the capabilities of the unified Markdown stack to Rust. It provides a CommonMark-compliant parser that can produce an MDAST (in fact, it uses the same mdast spec) or directly output HTML. Notably, markdown-rs supports all common extensions out-of-the-box: GitHub Flavored Markdown (100% of GFM features), MDX (JSX, ESM imports/exports, expressions), plus Frontmatter and LaTeX math blocks. This essentially mirrors the feature set one can achieve in JS via plugins, but baked into a single Rust crate. As a Rust library, it emphasizes performance and safety – it's implemented as a zero-copy state machine that accounts for every byte and uses no unsafe Rust. The parser emits a stream of events (tokens) which are then turned into either an AST or HTML, similar to how Remark+rehype have separate phases.

### Parsing and AST (mdast) Generation

Using markdown-rs feels somewhat analogous to using Remark, but in a Rust API. The crate exposes simple functions: `to_mdast(markdown_text)` returns an `mdast::Node` (the root of the AST), and `to_html(markdown_text)` returns an HTML string. There is also `to_html_with_options` to enable/disable extensions or unsafe HTML. By default, the parser is very strict to the CommonMark spec and does not enable extensions unless asked. For example, GFM features can be turned on via `Options::gfm()`, and MDX via Options or ParseOptions for MDX. If an extension is enabled, the parser will recognize that syntax and produce appropriate AST nodes (e.g. a footnote node, or MDX JSX node). The AST types in markdown-rs are provided under the mdast module and closely follow the unist/mdast specification. This means you'll find node structs for Heading, Paragraph, List, MdxJsxTextElement, etc., matching the ones in the JS ecosystem. The Rust AST nodes carry source position info as well (for error reporting or mapping back to text). A key achievement is that MDX is fully supported: the Rust parser can parse MDX syntax (including embedded JSX and import/export blocks) at 100% compliance. This is unique among Rust parsers – earlier Rust libraries (like pulldown-cmark or comrak) do not handle MDX or many GFM features natively.

### HTML Rendering and Safety

The `to_html()` functionality in markdown-rs compiles the event stream into HTML. By default, the output is safe HTML – any raw HTML in the source Markdown is escaped or dropped to prevent XSS. This behavior differs from Remark, which by default would pass through HTML (leaving sanitization to the user). In Rust, the crate follows a secure-by-default philosophy (you can override this by setting `allow_dangerous_html` in options if you trust the input). The HTML output aims to be spec-compliant and safe (it even includes the GFM-specific Tagfilter which blocks certain raw HTML tags by default). This makes markdown-rs suitable for untrusted content scenarios out-of-the-box. If needed, you can configure options to allow raw HTML or even to allow custom protocols (like `javascript:` links, which are disallowed by default). The HTML renderer also accounts for all GFM additions (for instance, GFM task list items are rendered as checkboxes with disabled attribute, etc.).

### Extensions and Customization

Whereas the JS ecosystem achieves extensions via plugins, markdown-rs has them built-in as toggleable features. It supports GFM features (autolink literals, tables, strikethrough, task lists, footnotes) and MDX (JSX, MDX expressions, MDX ESM import/exports), plus frontmatter and math blocks. These were chosen as "very common and mostly standardized extensions". However, defining new syntax extensions in markdown-rs is not currently exposed as an easy plugin interface. The project maintainers have stated that supporting lots of arbitrary extensions is not a goal (they prefer to stick to common ones). In fact, an issue about enabling custom plugins in Rust was raised, asking if one could provide their own syntax (e.g. for "fancy code blocks" or diagram syntaxes); the maintainer's stance suggested that at the moment this isn't supported and might remain a non-goal unless there's significant demand. By contrast, the Rust crate mdxjs-rs exists to handle one specific "extension" – it wraps markdown-rs to compile MDX into actual JavaScript/JSX output. Essentially, mdxjs-rs takes the MDX AST (with JSX nodes) and outputs a ready-to-use JSX/TSX module, akin to what @mdx-js/mdx does in the JS world. This indicates that for specialized needs like MDX-to-JS compilation, separate tooling is provided. For any other custom DSL or syntax not supported, a Rust developer would currently have to preprocess the input or fork/modify the parser. For example, if you wanted a custom directive syntax in Markdown (not covered by the built-ins), you might scan the text and transform those sections before feeding to the parser, or traverse the AST after parsing (if they appear as generic nodes like HTML or code) and then post-process. There isn't an out-of-the-box plugin system like unified's `.use()` pipeline for third-party Rust plugins.

### Transformations and Linting

Once you have the Rust MDAST from `to_mdast()`, you can manipulate it using regular Rust code. The AST is comprised of Rust enums/structs, so you might traverse it (e.g. using pattern matching or a visitor) to make changes. For instance, you could write a function to visit all Image nodes and modify their URLs, or find all code blocks of a certain language and run an external syntax highlighter, etc. After modifying the AST, you currently would need to either convert it back to Markdown or directly to HTML manually. As of late 2024, markdown-rs is gaining the ability to serialize MDAST back to markdown (an update added a `Node::to_string()` or similar functionality). With that, a round-trip is possible: parse to AST, transform, then serialize to markdown (and optionally re-run `to_html` on that). A more direct route (AST -> HTML) is not provided as a single public API, but you can emulate it by using the crate's internal logic or by round-tripping through markdown text. In practice, because Rust is compiled, many use-cases would integrate at a different level (e.g. applying transformations in the code rather than needing an external "plugin" mechanism).

On the linting/diagnostic side, the Rust ecosystem does not yet have an equivalent to remark-lint. There is interest in it – for example, community members have discussed porting markdownlint (a popular Markdown linter) to Rust – but as of 2025 no widely-adopted Rust Markdown linter exists. That said, with the AST and Rust's speed, one could implement specific lint rules fairly easily by traversing the AST for patterns. The markdown-rs crate itself will report syntax errors in Markdown only for MDX (because standard Markdown is designed not to produce hard errors). If an MDX parsing error occurs (e.g. an unclosed JSX tag or invalid JS expression), `to_html_with_options` (and `to_mdast`) return a `Result<…, markdown::Message>` where the error Message includes the line/column and description of the issue. For example, if you forget a closing brace in an MDX `{ expression }`, the error will pinpoint where it was expected. Outside of MDX, the parser tries to handle input without crashing (even pathological cases), so you won't get parse errors for things like a lone `]` or mismatched backticks – those become part of the AST as text. Like Remark, markdown-rs attaches position info to AST nodes, so if you write a custom lint or transform, you can produce your own warnings or errors referencing original positions.

### Surrounding Tooling

The Rust ecosystem around markdown is still growing. Apart from markdown-rs and its companion mdxjs-rs, there are other libraries that serve specific needs. Prior to markdown-rs, the dominant Rust libraries were pulldown-cmark (a fast streaming parser for CommonMark) and Comrak (which parses to an AST and supports CommonMark + GFM). Comrak can produce an AST (its own structure) and even has an HTML renderer, and it allows some custom rendering (you can override how nodes render), but it doesn't support MDX or some advanced syntax. Another interesting crate is markdown-ast (by a different author), which provides an AST data structure and utility to convert to/from pulldown-cmark's event stream. That one was intended to make it easier to programmatically build or modify Markdown content in Rust. However, with markdown-rs offering mdast, it largely overlaps in functionality (and markdown-rs is closer to the standardized mdast format). For HTML rendering, besides the built-in functions, one could imagine a rehype equivalent in Rust in the future. Currently, if you needed to manipulate an HTML AST in Rust, you'd use an HTML parser (like lol_html or html5ever) on the output, since markdown-rs doesn't expose a structured HTML tree – it directly emits a string. In terms of integration, markdown-rs being a Rust crate means it can be embedded in any Rust application (e.g. static site generators, note-taking tools, etc.). It's also capable of compiling to WASM or being used via FFI for other languages. In fact, the author notes it's possible to use it in WebAssembly (the crate is `#![no_std]` compatible), and projects like Streamdown (an AI streaming markdown renderer by Vercel) have leveraged its speed in web contexts. Early benchmarks indicate that performance is a big win for the Rust approach: one test showed a native Rust markdown parser (integrated via N-API or WASM) could "handily beat" the Remark pipeline in throughput. This is consistent with the expectation that Rust's optimized code can process text much faster than JS. That said, certain highly-optimized C libraries (and their JS bindings like Marked) are also very fast; in one comparison the Rust parser (pulldown via N-API) was on par with the fastest C/JS parser (marked) and both were significantly faster than remark. For most real use cases, the difference means Rust can handle larger files or more requests per second, whereas JS might become a bottleneck for huge documents or real-time applications.

### Composability and Use Cases

Using markdown-rs for markdown+DSL compositions typically requires a bit of custom coding, as there's no ready-made plugin system to, say, "include an external file" or "evaluate a custom directive". However, one can achieve similar outcomes. For example, if you want to compose multiple markdown files into one, you could parse each to an AST and then merge their children. If you have a custom DSL (say, `<<diagram>>` tags in text), the parser will likely treat those as HTML or text nodes (if it doesn't recognize them). You can then post-process the AST: find those pattern nodes and replace them with whatever you need (perhaps an Image node or an HTML node with rendered content). Essentially, you have full control in Rust code to manipulate the AST – it's just not as high-level as writing a remark plugin with a nice API. The upside is performance and type safety; the downside is reimplementing logic that might already exist as a JS plugin. As of now, if your use-case heavily relies on existing plugins (like say a plugin that merges markdown files, or one that generates a table of contents), you won't find a direct Rust equivalent ready to use – you'd have to port it. On the other hand, for use-cases like a Rust-based static site generator or a content processor where you want maximum speed and to avoid Node.js, markdown-rs provides an appealing solution. It brings nearly feature-parity in parsing with the JS ecosystem (even including edge cases of MDX and GFM), and it produces the same kind of AST structure (which could even enable interesting cross-language possibilities, like generating an mdast JSON in Rust and feeding it to a JS tool or vice versa, since both speak "mdast" format with unist nodes).

## Feature Comparison

| Feature / Aspect | TypeScript Ecosystem (Remark/Unified) | Rust Ecosystem (markdown-rs) |
|------------------|---------------------------------------|------------------------------|
| **Markdown Compliance** | 100% CommonMark compliant (via remark-parse). GFM support via plugin (remark-gfm). | 100% CommonMark compliant. GFM support built-in (enable via options). |
| **MDX Support** | Yes – via remark-mdx plugin (parses MDX syntax into AST) and compiled with MDX library. Mature (MDX v2) ecosystem for React/JS. | Yes – built-in MDX parsing (JSX, expressions, import/export) at 100% spec. Output to JS/JSX via companion crate mdxjs-rs. No React runtime; meant for compilation or analysis. |
| **AST Format (MDAST)** | Uses mdast (unist) nodes in JavaScript (e.g. via unist-util-visit). Full tree includes positions. Rich node types including custom ones added by plugins. | Uses mdast nodes in Rust (markdown::mdast::*). Mirrors the spec (Node enums like Root, Paragraph, Heading, including MDX node types). All nodes have positional info (Point, Position in unist module). Serializable via Serde (optional). |
| **Parsing Speed** | Moderate. Parsing and transforming large files in JS is slower; one benchmark showed Remark ~5-10× slower than fast C/JS parsers. Adequate for most docs, but not optimized for huge input. | High. Rust parser is very fast (state-machine implementation) – in tests, a native Rust parser beat Remark's throughput easily, matching C libraries. Suitable for large scale or performance-critical scenarios. |
| **Transforms/Plugins** | Extensive plugin ecosystem (150+ plugins). Plugins for TOC generation, image handling, embed content, SEO, etc. Easy to write new plugins (using AST utilities like unist-util-visit and mdast-util-*). Compose via `.use()` pipeline. | No official plugin system for new syntax or transforms. Extensions limited to built-in GFM/MDX. Custom transformations done by user code (manipulating AST in Rust). Integration points (like customizing rendering of a specific node) require modifying AST or forking. |
| **Linting & Diagnostics** | remark-lint provides ~70 rules (style guide, consistency, common errors). Warnings are attached to file with line/col info. Other diagnostic plugins (link checker, etc.) available. MDX errors surfaced via exceptions with acorn messages. | No built-in lint rules. Users can traverse AST to implement checks. No ready-made Rust linter yet (though possible to create). Parser returns error objects for MDX syntax issues with detailed message/position. Standard Markdown parsing yields no errors (handles edge cases internally). |
| **HTML Output** | Through rehype: convert to HTML AST then to string. Allows use of rehype plugins (e.g. sanitization, syntax highlight). Alternatively, libraries like react-markdown can render AST to React directly. Raw HTML in input is preserved by default (or sanitized via rehype plugin). | Via built-in HTML renderer: `to_html()` directly returns HTML string. Output is sanitized by default (dangerous tags and protocols are escaped). Options to allow raw HTML if needed. No intermediate HTML AST exposed (would need to parse output if needed). |
| **Other Output Formats** | Markdown: remark-stringify to output MD from AST (supports frontmatter, etc). Other: custom compilers can generate e.g. LaTeX, etc., but not common. Unified AST can also be serialized to JSON easily (via hast/mdast to JSON). | Markdown: Supported (as of 2024) via AST serialization (round-trip conversion). JSON: With serde feature, AST can be serialized to JSON (useful for cross-language usage or debugging). Direct export to other formats (e.g. PDF) not provided, but one could convert HTML output or traverse AST to generate other outputs. |
| **Extensibility (Custom Syntax)** | Very high. New syntax can be added with micromark extensions + mdast utilities (advanced). For simpler cases, remark plugins can post-process the AST. Many community extensions exist (e.g. footnotes, typographic replacements, admonitions). Virtually any markdown variant can be implemented. | Limited. Currently cannot register new syntax without modifying the source. Parser only recognizes built-in extensions. Custom syntax handling would be manual (preprocess text or post-process AST). An issue for plugin support is open, but maintainers focus only on common extensions. |
| **Composition of Docs/DSL** | Multi-file: not inherently supported by Remark, but achievable via plugins or MDX imports. E.g. MDX allows `import Content from './other.md'` (treats it as a component). Plugins like remark-include (if updated) can inline file contents. DSL embedding: handled via plugins that either transform custom syntax to AST nodes or treat them as raw HTML. Strong integration with MDX for mixing JSX (for interactive DSLs). | Multi-file: no built-in include mechanism. User can concatenate files or merge ASTs in Rust code. DSL embedding: no direct MDX-like evaluation (aside from MDX itself). One can find custom markers in the AST and replace them (e.g. replace a code block of language "mermaid" with an image HTML tag after generating a diagram). Essentially, requires manual AST transform logic per DSL. No native execution of embedded scripts (Rust is not executing JSX; MDX is compiled to JS externally). |
| **Community & Usage** | Very mature and widely used. Backed by unified collective; used in many tools (e.g. Next.js, Gatsby, contentlint, etc.). Community plugins cover most needs. Active development (latest remark 14, unified 10). Excellent documentation and type definitions (TypeScript types for mdast, hast, etc.). | Fast-growing interest. markdown-rs reached 1.0 in 2023 with support from Vercel. Used in some projects for performance (e.g. Vercel's AI demo tools). Still gaining traction in the Rust community (potential for integration in static site gens like Zola or mdBook in future). Documentation is decent (Rust docs, examples), and being by the same author as Remark, it aligns with known specs. |

## Authors & Versions

The TypeScript unified/remark ecosystem was primarily developed by Titus Wormer (whose GitHub handle is wooorm), and has been around since 2014. Remark is currently at version 14 (ESM-only) and unified at version 10 (approximately). The Rust markdown-rs library is a more recent project (initial commit in 2022, with Vercel sponsoring) and is also maintained by Titus (the Rust crate lists him as the owner). As of late 2024, markdown-rs is at version 1.0.x, indicating a stable API. Both ecosystems are open-source and actively maintained. The unified collective has a large community contributing plugins in JS, whereas the Rust project is smaller but benefitting from the upstream knowledge and tests – in fact, markdown-rs is tested against ~2300 CommonMark/GFM examples and thousands of additional cases to ensure it matches the behavior of reference parsers. This cross-pollination means the two ecosystems produce very similar ASTs and HTML for the same markdown input (aside from intentional differences like HTML sanitization).

## Use-Case Suitability

In summary, each ecosystem has its strengths:

- **Feature Parity**: In terms of pure features (supported Markdown flavor, AST detail, etc.), Rust's markdown-rs has essentially caught up with the JS ecosystem – it implements all major flavors (CommonMark, GFM, MDX) and produces the same kind of AST (mdast). The JS ecosystem, however, has a broader array of surrounding tools – for example, if you need to lint markdown, format it, convert it to React components, or integrate with web bundlers, those tools already exist for Remark/MDX. Rust currently provides the core parsing/rendering but fewer ready-made high-level tools.

- **Diagnostics**: If you need comprehensive diagnostics, the JS route (Remark + remark-lint, etc.) is currently more polished. You get off-the-shelf style guides and error checks. In Rust, you might choose it for performance or safety, but you'd have to implement any specific lint rules yourself or wait for community solutions. Both can report errors with accurate positions – Remark/Unified via vfile messages, and markdown-rs via its Message error type for parse errors.

- **Plugin Ecosystem & Customization**: The unified (JS) ecosystem is unparalleled in customizability. This makes it ideal if you have to support a custom markdown dialect or embed a domain-specific language. You can likely find a plugin that already does what you need (or write one with relatively little effort using unified's APIs). For example, to embed Graphviz diagrams in markdown, in JS you might use remark-graphviz plugin; to add custom containers, use remark-directive. In Rust, such a scenario would entail manual handling – you might parse the markdown, then for each occurrence of the pattern, inject your own HTML or precomputed output. It's doable, but not plug-and-play.

- **Performance**: If parsing/rendering speed or resource usage is a top priority (e.g. a server that must handle thousands of markdown renders per second, or very large documents), the Rust implementation has a clear advantage. Being able to generate HTML in native code can be an order of magnitude faster than running a Node.js parser. Also, Rust gives more predictable memory usage without garbage collection pauses. That said, for client-side applications (browsers), the JS ecosystem is more directly usable (Rust would need to compile to WASM). There are efforts to use markdown-rs via WASM for performance – anecdotally, even with WASM overhead, it can outperform pure JS for heavy workloads, but integration complexity should be considered.

- **Integration and Ecosystem Fit**: If you are in a primarily JavaScript/TypeScript environment (such as a Next.js app or a documentation toolchain using Node), using Remark/MDX will fit naturally. You'll benefit from existing integrations (like MDX in Next.js, or remark plugins in Eleventy, etc.). In a Rust environment (such as a Rust-powered static site generator or a command-line tool), using markdown-rs avoids needing to call out to Node or include JS dependencies. We are also seeing hybrid approaches: for example, one could use markdown-rs in a build step and then pass the AST or HTML to a web frontend. Since both use compatible AST specs, an interesting possibility is generating an AST in one ecosystem and consuming it in the other – e.g., a Rust backend could send an mdast JSON to a frontend which renders it with React. This is facilitated by the shared mdast format.

- **Suitability for Markdown+DSL composition**: If your use case is something like "take markdown content with embedded special syntax and produce HTML output," both ecosystems can handle it, but via different means. The JS ecosystem would encourage writing a custom remark plugin or using MDX if the DSL can be expressed as JSX components. This provides a structured solution (AST transformation or component rendering). The Rust ecosystem would require you to detect and handle the DSL either before or after parsing. For example, if the DSL is indicated by custom fenced code blocks (` ```mydsl ...``` `), you could parse normally (they become code block nodes) and then post-process those nodes in Rust – perhaps converting them to HTML with the help of an external library or API. The performance of Rust could allow doing heavier computation per DSL block without hiccups. However, you'd be writing that integration code yourself, whereas in JS someone might have already written a plugin. In short: JS/Remark is better when you need turnkey solutions and maximum flexibility; Rust/markdown-rs shines when speed, memory safety, or integration into a Rust codebase is paramount.

Both ecosystems are actively maintained by the same knowledgeable author and community, ensuring that neither lags behind in markdown specification updates. If you need to ensure exact rendering consistency between JS and Rust (for example, in a system where some markdown is rendered on the server in Rust and some on the client in JS), using the mdast approach in both is advantageous – they strive to produce the same AST and HTML for the same input. In conclusion, the TypeScript MDAST ecosystem (Remark/Unified) offers a rich, extensible, and well-integrated platform for markdown processing with a vast plugin library and established workflows, making it ideal for complex content pipelines and developer ergonomics. The Rust ecosystem (markdown-rs) provides a highly compliant and efficient core engine with the major features one would expect (AST, GFM, MDX, etc.) and yields performance and safety benefits; it is catching up in terms of tooling and will appeal for use-cases where those benefits outweigh the need for pre-existing plugins. Many scenarios can even mix the two: for example, author content in MDX (leveraging its JSX component system in a React app), but use Rust on the backend to quickly parse and serialize content or to pre-render parts of it. As the ecosystems evolve, we may see even more convergence (perhaps a plugin interface in Rust, or more use of Rust under the hood in JS via WASM), giving developers the "best of both worlds" – but at present, the choice often comes down to the requirements of customization vs. performance and the environment in which you're operating.

## Sources

- [Intro to unified](https://unifiedjs.com/learn/guide/introduction-to-unified/)
- [Using plugins – unified](https://unifiedjs.com/learn/guide/using-plugins/)
- [Processing Markdown with remark and unified plugins](https://brunoscheufler.com/blog/2021-04-18-processing-markdown-with-remark-and-unified-plugins)
- [remark – unified package page](https://unifiedjs.com/explore/package/remark/)
- [remark GitHub repository](https://github.com/remarkjs/remark)
- [awesome remark (curated list of plugins)](https://github.com/remarkjs/awesome-remark)
- [Create a remark plugin – unified guide](https://unifiedjs.com/learn/guide/create-a-remark-plugin/)
- [@mdx-js/mdx – GitHub](https://github.com/mdx-js/mdx)
- [MDX docs site](https://mdxjs.com/)
- [markdown-rs GitHub repository](https://github.com/wooorm/markdown-rs)
- [markdown crate docs on docs.rs](https://docs.rs/markdown/)
- [Rust Bytes: Rust Is Powering Vercel's Turborepo](https://medium.com/rustaceans/rust-bytes-rust-is-powering-vercels-turborepo-e1698ac9b3c8)
- [markdown-rs issues](https://github.com/wooorm/markdown-rs/issues)
- [markdown-rs Q&A discussions](https://github.com/wooorm/markdown-rs/discussions/categories/q-a)
- [An Introduction to Unified and Remark](https://braincoke.fr/blog/2020/03/an-introduction-to-unified-and-remark/)
